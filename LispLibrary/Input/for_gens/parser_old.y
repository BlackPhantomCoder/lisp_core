/* Demonstrates Bison C++ complete interface see Bison 10.1.6.2 Complete Symbols */
/* Compile: reflex --flex --bison-complete --bison-locations flexexample11.lxx */
/* Compile: bison -d reflexexample11.yxx */

%require "3.2"

%language "c++"
%define api.namespace {yy}
%define api.parser.class {parser}
%define api.value.type variant
%define api.token.constructor

%define parse.error verbose

%defines "parser.h"
%output "parser.cpp"

%locations
%define api.location.file "location.h"

%parse-param { MyScanner& lexer }


%define api.token.prefix {TOK_}

%code requires {
    #include <string>
    #include <deque>
    #include "BigInt.h"
    #include "Cell.h"
    #include "SExprsFarm.h"
    struct BIDC {
        BigInt data = BigInt(0l);
    };
    typedef std::deque<Cell> celldec;
    class MyScanner;
}

%code{
#include "Funcs.h"
    #include "Input/MyScanner.h"  /* Generated by reflex. */
    #undef yylex
    #define yylex lexer.my_yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    
    #include <sstream>
    //auto b = std::ostringstream();
    //auto&}// mout  = b;
    //auto& mout  = std::cout;
}

%token <std::string> str
%token <std::string> symbol
%token <BIDC> z_numb
%token <double> r_numb
%token <Cell> Macro

%token '(';
%token ')';
%token '.';
%token '\'';

%type <Cell> S
%type <Cell> S_forse_accept
%type <Cell> S_and_symbols
%type <Cell> A
%type <Cell> N
%type <Cell> Dp
%type <Cell> L
%type <Cell> Add
%type <celldec> Sp
%type <Cell> Q

%%
START : S_forse_accept          { lexer.set_result($1); }
S_forse_accept: S_and_symbols   { if (lexer.is_single()) { lexer.set_result($1); YYACCEPT; } }
S_and_symbols: S | '.'          { $$ = lexer.get_farm().make_symbol_cell("."); }
S  : A | Dp | L | Add |  Macro  { $$ = $1; }// mout  << "[Macro]" << lexer.t_env.core_env.t_output_control.to_string($1) << std::endl; }
A  :
    str                         { $$ = lexer.get_farm().make_symbol_cell(std::move($1)); }// mout  << "[str]" << lexer.t_env.core_env.t_output_control.to_string($$) <<std::endl;};
    |
    symbol                      { $$ = lexer.get_farm().make_symbol_cell(std::move($1)); }// mout  << "[symbol]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
    |
    N
    ;
N  :
    z_numb                      { $$ = lexer.get_farm().make_number_cell($1.data); }// mout  << "[z_numb]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
    |
    r_numb                      { $$ = lexer.get_farm().make_number_cell($1); }// mout  << "[r_numb]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
    ;
Dp: '(' Sp '.' S ')'            { auto buf = $2; buf.push_back($4); $$ = make_dpair(buf, lexer.get_farm()); }// mout  << "[Dp]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
Sp :
    S Sp                        { $$ = $2; $$.push_front($1); };
    |
    S                           { $$ = celldec{$1}; };
    ;
L: '(' Sp ')'                   { $$ = lexer.get_farm().make_list_cell(begin($2), end($2)); }// mout  << "[L]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
    |
    '(' ')'                     { $$ = lexer.get_farm().make_list_cell({}); }// mout  << "[empty L]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
Add : Q ;
Q   : '\'' S                    { $$ = lexer.get_farm().make_list_cell({ lexer.get_farm().make_symbol_cell("QUOTE"), $2 }); }// mout  << "[quote]" << lexer.t_env.core_env.t_output_control.to_string($$) << std::endl; };
%%

void yy::parser::error(const location& loc, const std::string& msg)
{
    if (msg == "syntax error, unexpected end of file") {
        throw throw_eof{};
    }
    throw throw_my_syntax_error{loc, msg};
//  if (lexer.size() == 0)      // if token is unknown (no match)
//    lexer.matcher().winput(); // skip character
}
